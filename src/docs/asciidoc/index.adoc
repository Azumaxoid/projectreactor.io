:doctype: book

= Documentation
Project Reactor reference documentation, code samples, and Javadoc.

++++
include::nav.html[]
include::breadcrumb.html[tags="pre"]
include::breadcrumb.html[tags="post"]
++++

<<getting-started,Getting Started>>:: How to get going quickly with Reactor.
link:/docs/reference/[Reference]:: Reference documentation covering the basic components of Reactor as well as more advanced concepts.
link:/docs/api/[Javadoc]:: Documentation on the Reactor API.

[[introduction]]
== What is Reactor?

Reactor is a foundational library for building reactive fast-data applications on the JVM. You can use any JVM langauge, from Java 7 or Java 8, to Scala, Groovy, or even Nashorn JavaScript. It's designed to be fast and efficient to enable you to write asynchronous applications that can manage extremely high workloads with very little overhead. It builds on the extreme throughput capabilities of the https://github.com/LMAX-Exchange/disruptor[Disruptor RingBuffer] to achieve throughput in the 10's of _millions_ of operations per second (even up to 100's if you have enough hardware horsepower).footnoteref:[benchmark,Reactor microbenchmarks are maintained in a https://github.com/reactor/reactor-benchmark[separate GitHub repository]]

[[getting-started]]
== Getting Started

To add Reactor to an existing project, you just need to include the appropriate artifact. The basic components of Reactor like `EventBus` and `Stream` are in the `reactor-core` artifact. Additional functionality is in the `reactor-net`, `reactor-groovy`, and `reactor-logback` modules.

[pass]
<div class="ui segment">

.build.gradle
[source,groovy]
----
ext {
  reactorVersion = '2.0.0.M2'
}

repositories {
  // maven { url 'http://repo.spring.io/libs-milestone' } // <1>
  // maven { url 'http://repo.spring.io/libs-snapshot' } // <2>
}

dependencies {
  compile "io.projectreactor:reactor-core:$reactorVersion"
}
----
<1> Uncomment to use a milestone version.
<2> Uncomment to use a snapshot version.

[pass]
</div>

Now that you've added the Reactor library to your project, you can start using the `Stream` class to perform high-volume, low-latency, asynchronous work. It's really almost deceptively simple. Here's a completle Hello World to get you started.

[pass]
<div class="ui segment">

.ReactorHelloWorld.java
[source,java]
----
import reactor.Environment;
import reactor.rx.Streams;
import reactor.rx.stream.Broadcaster;

public class ReactorHelloWorld {
  public static void main(String... args) throws InterruptedException {
    Environment.initialize();

    Broadcaster<String> sink = Streams.broadcast(Environment.get());

    sink.dispatchOn(Environment.cachedDispatcher()) // <1>
        .map(String::toUpperCase) // <2>
        .consume(s -> System.out.printf("s=%s%n", s)); // <3>

    sink.onNext("Hello World!");

    Thread.sleep(500);
  }
}
----
<1> Dispatch tasks onto a load-balanced `Dispatcher`.
<2> Transform the input to upper-case and send to next stage.
<3> Consume the transformed input and print to STDOUT.

[pass]
</div>

[[dispatching]]
=== Dispatching is Fundamental

In Reactor, you'll find a lot of references to, and talk about, dispatching. Unlike almost all other asynchronous frameworks out there, Reactor takes dispatching tasks very seriously and it is a first-class concern. It might be tempting to think that what thread a task should be executed on is not something you as a developer want to have to worry about. But when you're dealing with asynchronous tasks, you quickly discover that it's impossible to develop a sane API around a set of blocking calls that have to tie up a thread to wait for work. As soon as your first task is complete and you want to notify the "next" task that a result is available, you find out just how important it is to assign a `Dispatcher` to your composition and let the framework handle when and where to execute your callback.